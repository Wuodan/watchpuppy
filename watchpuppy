#!/usr/bin/env sh

# Copyright (c) 2024 Stefan Kuhn
# Licensed under the MIT License

set -e

SCRIPT_DIR=$(dirname "$0")
SCRIPT_NAME="watchpuppy"

# LOG_LEVEL
LOG_LEVEL=${WATCHPUPPY_LOG_LEVEL:-$LOG_LEVEL}
LOG_LEVEL=${LOG_LEVEL:-"INFO"}
LOG_LEVEL=$(echo "$LOG_LEVEL" | tr '[:lower:]' '[:upper:]')

# Function to map log level names to numeric values
get_log_level_num() {
  case "$1" in
    "DEBUG") echo 10 ;;
    "INFO") echo 20 ;;
    "WARNING"|"WARN") echo 30 ;;
    "ERROR") echo 40 ;;
    "CRITICAL") echo 50 ;;
    *) echo 100 ;;  # Default to 100 for unknown levels
  esac
}

# Set the log level number only once
LOG_LEVEL_NUM=$(get_log_level_num "$LOG_LEVEL")

log() {
  LEVEL=$1
  MESSAGE=$2

  # Get numeric value for the current log level
  LEVEL_NUM=$(get_log_level_num "$LEVEL")

  # Output log message if the message level is >= log level
  if [ "$LEVEL_NUM" -ge "$LOG_LEVEL_NUM" ]; then
    echo "$SCRIPT_NAME - $LEVEL - $MESSAGE"
  fi
}

# todo watch modified as in python
monitor_directory() {
    inotifywait -m -r -e close_write --format '%w%f' "$WATCH_DIR" | while read -r NEWFILE; do
        log "DEBUG" "New file detected: $NEWFILE"
        log "INFO" "Running process script: ['$PROCESS_SCRIPT' '$NEWFILE']"
        "$PROCESS_SCRIPT" "$NEWFILE"
    done
}

# Check if the filesystem type supports inotify
check_inotify_support() {
    # These file systems do not support inotify
    if [ "$FS_TYPE" = "9p" ] || [ "$FS_TYPE" = "fuse" ] || [ "$FS_TYPE" = "nfs" ] || [ "$FS_TYPE" = "cifs" ]; then
        log "DEBUG" "File system '$FS_TYPE' of '$WATCH_DIR' does not support inotifywait. Switching to Python polling."
        return 1
    elif [ -z "$FS_TYPE" ]; then
        log "WARN" "FS_TYPE was $FS_TYPE"
        log "WARN" "Could not determine file system of '$WATCH_DIR', falling back to Python polling. Full output of df -T \"$WATCH_DIR\" is: $(df -T "$WATCH_DIR" | tr '\n' ' ')"
        return 1
    else
        log "DEBUG" "File system '$FS_TYPE' of '$WATCH_DIR' supports inotifywait. Using inotifywait."
    fi
}

# Check if exactly two arguments are provided
if [ $# -ne 2 ]; then
    log "ERROR" "Usage: $0 /path/to/directory /path/to/process-script"
    exit 1
fi

WATCH_DIR="$1"
PROCESS_SCRIPT="$2"


if [ ! -d "$WATCH_DIR" ]; then
    log "CRITICAL" "Directory '$WATCH_DIR' does exists."
    return 1
fi

# Read file system type
FS_TYPE="$(df -T "$WATCH_DIR" | awk 'NR==2 {print $2}')"

if check_inotify_support; then
    monitor_directory
else
    exec python3 "$SCRIPT_DIR"/watchpuppy.py "$WATCH_DIR" "$PROCESS_SCRIPT"
fi
